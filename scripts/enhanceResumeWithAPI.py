#!/usr/bin/env python3
"""
enhanceResumeWithAPI.py: Updates the resume JSON by integrating data from a job description using an external API.
This script reads a resume JSON file (generated by 1_parse_resume_yaml.py) and a job description text file,
builds a prompt that includes the resume content and job description, sends it to the Perplexity AI API, and
updates the resume JSON with the returned tailored content.

Usage:
    python3 enhanceResumeWithAPI.py --resume <path_to_resume_json> --jd <path_to_job_description_txt>

If --jd or --resume is not provided, the file paths will be taken from config.yml.
"""

import requests
import json
import os
import yaml
import argparse
import re

def load_config(config_path="config.yml"):
    with open(config_path, "r", encoding="utf-8") as f:
        config = yaml.safe_load(f)
    return config

def ask_perplexity(prompt, config):
    url = config.get("endpoint", "https://api.perplexity.ai/chat/completions")
    api_key = config.get("api_key")
    model = config.get("model", "sonar-pro")
    headers = {
        'accept': 'application/json',
        'content-type': 'application/json',
        'Authorization': f'Bearer {api_key}'
    }
    data = {
        "model": model,
        "messages": [
            {
                "role": "user",
                "content": prompt
            }
        ]
    }
    response = requests.post(url, headers=headers, json=data)
    if response.ok:
        return response.json()
    else:
        raise Exception(f"Request failed with status {response.status_code}: {response.text}")

def read_resume(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def read_job_description(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return f.read()
    
def extract_relevant_resume_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        resume = json.load(f)
    extracted = {
        "basics": {
            "summary": resume["basics"]["summary"]
        },
        "work": [
            {
                "company": job["company"],
                "highlights": job["highlights"]
            }
            for job in resume.get("work", [])
        ],
        "projects": [
            {
                "name": project["name"],
                "highlights": project["highlights"]
            }
            for project in resume.get("projects", [])
        ],
        "skills": resume.get("skills", [])
    }
    return extracted

def update_resume_file(updated_resume, file_path):
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(updated_resume, f, indent=4)

def main():
    parser = argparse.ArgumentParser(description="Update resume JSON via external API based on job description.")
    parser.add_argument('--resume', default=None, help="Path to resume JSON file created by 1_parse_resume_yaml.py")
    parser.add_argument('--jd', default=None, help="Path to job description text file")
    args = parser.parse_args()

    # Load configuration from config.yml
    config = load_config()

    # Determine file paths from command-line arguments or config file
    resume_file = args.resume if args.resume else config.get("resume_yaml", "resume.json")
    jd_file = args.jd if args.jd else config.get("job_description_file", "job_description.txt")

    if not os.path.exists(resume_file):
        raise FileNotFoundError(f"Resume file not found: {resume_file}")
    if not os.path.exists(jd_file):
        raise FileNotFoundError(f"Job description file not found: {jd_file}")

    # Extract relevant resume data and read job description text
    my_resume = extract_relevant_resume_data(resume_file)
    job_description = read_job_description(jd_file)

    # Build the prompt variable (including the long instructions)
    prompt = f""" You are my assistant and responsible to follow my instructions strictly. I am providing my resume content in json format in the variable "my_resume".
    Specifically, you need to update the summary section in the json given as basics['summary'], work, projects and skills. Your goal is to enhance my resume for job applications by adding missing keywords, skills and improving the bullet points of my existing professional experience as per the job requirement given in the variable job_description.

    Instructions:
    0. You are only allowed to follow below instructions and return the final output only.

    RULES FOR SUMMARY
    1. Read the given user summary from my_resume["basics"]["summary"].
    2. Tailor this summary as per the given job_description. 
    3. Your tailored summary must include all keywords required by ATS system for the given job_description. Tailored summary must be in the range of 50-150 words only.
    4. You are only allowed to store the response in a variable "summary".

    RULES FOR WORK
    5. Read all user work experiences from `my_resume["work"]`.
    6. This list may contain multiple work entries. Each entry includes a "company" and a list of "highlights" describing achievements and responsibilities.
    7. For each `my_resume["work"]["company"]`, generate a list of bullet points based on its "highlights", optimized using keywords from the provided `job_description`.
    8. Each bullet point must:
        - Begin with a strong action verb (e.g., Improved, Led, Developed, Designed, Automated).
        - Contain a specific, quantifiable impact (e.g., reduced cost by 25%, supported 3+ projects, served 5000+ users). If not available, infer realistic values.
        - Reference relevant skills, tools, or technologies aligned with the `job_description`.
        Be written clearly and professionally, between 15 and 30 words.
    9. Preserve the original `my_resume["work"]["company"]` name without modification. Return the final output strictly in the following JSON format:
    ```json
    "work" : [{{
    "company": work[i]["company"],
    "highlights": [] #Add your tailored bullet points inside this array/list.
    }}]
    Note - i denotes the no of work experience we are dealing, it may range from 0 to len(my_resume["work"])

    10. Avoid vague statements. Focus on achievements, technical contributions, and outcomes that demonstrate clear value to the employer.

    RULES FOR PROJECTS

    11. Read all user project entries from `my_resume["projects"]`.
    12. This variable may include one or more projects. Each project has a "name" and a list of "highlights" describing its scope, challenges, and accomplishments.
    13. For each `my_resume["projects"]["name"]`, generate **exactly five** bullet points based on its corresponding "highlights", using relevant keywords and terminology from the `job_description`.
    14. Each bullet point must:
        - Begin with a **strong action verb** (e.g., Developed, Engineered, Implemented, Automated, Integrated).
        - Clearly state the **problem solved or feature built**.
        - Reference specific **technologies, tools, or frameworks** used.
        - Include at least **one measurable impact** (e.g., reduced load time by 35%, processed 1M+ data rows, improved accuracy by 12%). If metrics are not provided, infer realistic values.
        - Be clear, professional, and **concise (15â€“25 words max)**.
    15. Do **not** change the value of `my_resume["projects"]["name"]`.
    16. Return the result **only** in the following JSON format:

    ```json
    "projects" :[ {{
    "name": work[i]["name"],
    "highlights": [] #Add your tailored bullet points inside this array/list.
    }}]

    Note - i denotes the no of work experience we are dealing, it may range from 0 to len(my_resume["projects"])

    17. Focus on technical contributions, engineering challenges, and results rather than general project descriptions.
    18. Avoid vague language. Ensure every point is action-driven, technically specific, and quantifiably impactful.

    RULES FOR SKILLS

    16. Read the given user skills from `my_resume["skills"]`.
    17. Reorganize the skills into meaningful categories. Each category must be its own dictionary inside the array.
    18.Add any missing relevant skills found in the `job_description`, and group them under the correct existing category. Avoid duplicates.
    19. Return the output strictly in the following format, using the variable name `skills`:
    
    "skills": [
    {{
    "skill_category": "", #Add the skill category as key and skills as value in string format, seperated by comma. Example "Programming Languages": "Python, Java, JavaScript",
    }}]

    20. Do not use key names like "skill_category" or "skills". Each object in the list should use the category name as the key, and the value must be a string of skills seperated by comma (,).
    21. Do not include extra fields. The category name (e.g., "Programming Languages") and the value must be "Python, Java, Javascript".

    FINAL INSTRUCTIONS

    20. Content Differentiation: Ensure that the content for projects and work experience is contextualized and distinct, reflecting the unique nature of the work experience in each company. Do not repeat or reuse the same sentences across both sections. Use the provided resume details to tailore appropriately.
    21. You must strictly return the output in the following JSON structure. Do not include any additional text, explanations, or comments. Only return the output variable in the exact format specified below. Ensure the content of the fields aligns with the context of the instructions but strictly preserve the structure.
    22. Modify and Enhance: While retaining the meaning and context of the original experience, you must enhance the text by focusing on relevant technologies, methodologies, and accomplishments unique to each role. Avoid directly copying the text from the resume without modification.
    23. - Do not add any additional fields, explanations, or comments in the JSON structure. Any output outside of the provided format will be considered invalid.
    24. - Your output must strictly match the format provided below:

    "output": {{
        "summary": summary, //Add summary varible here.
        "work": work, //Add work varible here.
        "projects": projects, //Add projects varible here.
        "skills": skills //Add skills variable here.
    }}

    IMPORTANT:
    - Return ONLY the final JSON inside a code block like ```json ... ``` without any explanations, thoughts, or commentary.
    - DO NOT include <think> tags, analysis, or any other text outside the JSON.
    - ONLY output pure JSON.


    Below is the content of my resume in json format, in the variable "my_resume":
    my_resume = {my_resume}

    Below is the job description for the role, I am looking to modify my resume in variable "job_description"
    job_description = {job_description}


    --END of PROMPT--
    """

    # Call the external API with the prompt.
    response = ask_perplexity(prompt, config)

    # Log full raw API response for debugging
    print('Perplexity raw response:', response)

    # Validate structure
    if 'choices' not in response or not response['choices']:
        raise ValueError(f"API call did not return expected 'choices'. Full response: {response}")

    
    # Parse the API response.
    content_str = response['choices'][0]['message'].get('content', '').strip()

    # Try to extract the JSON block safely
    matches = re.findall(r'```json\s*(\{.*?\})\s*```', content_str, re.DOTALL)

    if matches:
        json_block = matches[0]
        parsed_output = json.loads(json_block)
    else:
        # Fall back to original style if no triple-backtick found
        if content_str.strip().startswith('"output":'):
            content_str = '{' + content_str.strip() + '}'
        
        parsed_output = json.loads(content_str)
        
    summary = parsed_output['output']['summary']
    work = parsed_output['output']['work']
    projects = parsed_output['output']['projects']
    skills = parsed_output['output']['skills']

    # Update the original resume.json structure.
    resume_data = read_resume(resume_file)
    resume_data["basics"]["summary"] = summary

    for updated in work:
        for original in resume_data.get("work", []):
            if original.get("company") == updated.get("company"):
                original["highlights"] = updated.get("highlights")

    for updated in projects:
        for original in resume_data.get("projects", []):
            if original.get("name") == updated.get("name"):
                original["highlights"] = updated.get("highlights")

    resume_data["skills"] = skills

    update_resume_file(resume_data, resume_file)

if __name__ == "__main__":
    main()
